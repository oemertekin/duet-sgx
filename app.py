#!/usr/bin/env python

import os
import os.path
import json
from flask import Flask, request, render_template
import requests
import sys
import subprocess
from pathlib import Path
import time
from flask import jsonify

app = Flask(__name__)

################################################################################
# Set up filenames
################################################################################
epsilon_filename   = '/tmp/epsilon.txt'
delta_filename     = '/tmp/delta.txt'
query_filename     = '/tmp/query.ed.duet'
database_filename  = '/tmp/database.csv.encrypted'
duet_path          = os.environ['DUET_PATH'] # provided by environment variable or start_app.sh
try:
    ghc_flags     = os.environ['GHC_FLAGS']
except:
    ghc_flags = ''
    pass
output_filename    = '/tmp/output.json'

# make sure that the database exists
# otherwise a query on an empty database causes problems
if os.path.exists(database_filename):
    os.remove(database_filename)
Path(database_filename).touch()

################################################################################
# Start up the long-running Duet process
################################################################################
# we "toggle" /tmp/runquery to start the query running
if os.path.exists('/tmp/runquery'):
    os.remove('/tmp/runquery')
handle = open('/tmp/runquery', 'w')
handle.write('0')
handle.close()

# the Duet process keeps running while the server is running
cmd = '{} run {} {} {} {} {}'.format(duet_path, query_filename, epsilon_filename, delta_filename, database_filename, ghc_flags)
print(cmd)
subprocess.Popen(cmd, shell=True)

################################################################################
# Returns Remaining Epsilon
################################################################################
@app.route('/epsilon', methods=['GET'])
def get_epsilon():
    handle = open('/tmp/epsilon.txt')
    budget = handle.read().split(',')
    data = { "epsilon" : budget[0] , "signature" : budget[1] }
    return json.dumps(data)

################################################################################
# Returns Remaining Delta
################################################################################
@app.route('/delta', methods=['GET'])
def get_delta():
    handle = open('/tmp/delta.txt')
    budget = handle.read().split(',')
    data = { "delta" : budget[0] , "signature" : budget[1] }
    return json.dumps(data)

################################################################################
# Remote Attestation
################################################################################
@app.route('/attest', methods=['GET'])
def attest():
    print("Got attestation request")

    url     = 'https://api.trustedservices.intel.com/sgx/dev/attestation/v3/report'
    path    = os.path.expanduser("~") + "/graphene/LibOS/shim/test/native"
    try:
        quote   = open(path + '/quote.tmp', 'r')
    except:
        quote   = "Attestation quote not available"

    return quote

################################################################################
# Retrieve Public Key Randomly Generated by Duet ([e,n] version) --deprecated--
################################################################################
@app.route('/pubkey', methods=['GET'])
def getpubkey():
    with open('/tmp/duetpublickey') as key_file:
        key_data=key_file.read()
        d = json.loads(key_data)
        d['n'] = str(d['n'])
        key_data=json.dumps(d)

    return key_data

################################################################################
# Retrieve Public Key Randomly Generated by Duet (PEM version)
################################################################################
@app.route('/pubkeypem', methods=['GET'])
def getpubkeypem():
    with open('/tmp/duetpublickey.pem') as key_file:
        key_data=key_file.read()
    return json.dumps(key_data)

################################################################################
# Data Insertion
################################################################################
@app.route('/insert', methods=['POST'])
def insert():
    print("Got insertion request")

    #content = request.json
    content = request.get_json(force=True)
    #content = json.loads(content)
    #print(request.values["value"])
    #content =  request.values["value"]
    #csv_line = content
    csv_line = content['value']

    print("Writing the following lines to the database:")
    print(csv_line)

    # TODO: add .encrypted to make this an encrypted database
    with open(database_filename, "a") as myfile:
        myfile.write(csv_line + "\n")

    return "Insertion successful\n"

################################################################################
# Query
################################################################################
@app.route('/query', methods=['POST'])
def query():
    print("Got query request")

    #content = request.json
    content = request.get_json(force=True)
    print(content)
    #content = json.loads(content)
    #print(content)

    # We pad query with whitespace to fix the issue where successive queries
    # with char length greater than first query become truncated. SGX specific.
    query_len = len(content)
    query = content.ljust(query_len + 100)

    # put the arguments in files
    writefile(query, query_filename)

    # run Duet on the program
    if os.path.exists(output_filename):
        os.remove(output_filename)
    handle = open('/tmp/runquery', 'w')
    handle.write('1')
    handle.close()

    # Wait until it's done
    while not os.path.exists(output_filename):
        time.sleep(0.1)
        print("Output file not found, waiting...")
        sys.stdout.flush()

    # Read in the results
    with open(output_filename) as json_file:
        data = json.load(json_file)
        print(data)

    # Return the results
    return jsonify(
        result=data
    )

# Completely overwrites file and ensure unicode encoding
def writefile(string, filename):
    with open(filename, "w", encoding='utf-8') as myfile:
        myfile.flush()
        myfile.write(string)

################################################################################
# Frontend
################################################################################
@app.route('/', methods=['GET'])
def home():
    return render_template('webapp.html')
